# IDRM 分层架构设计

## 架构概览

IDRM采用经典的分层架构（Layered Architecture），结合领域驱动设计（DDD）思想，将系统划分为4个主要层次。

## 架构图

```
┌─────────────────────────────────────────────────────────────┐
│                        客户端层                              │
│              (Web / Mobile / Admin Console)                 │
└────────────────────────┬────────────────────────────────────┘
                         │ HTTP/gRPC
                         ▼
┌─────────────────────────────────────────────────────────────┐
│                      应用层 (app/)                           │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐   │
│  │   API    │  │   BFF    │  │   Job    │  │ Consumer │   │
│  │  Layer   │  │  Layer   │  │  Layer   │  │  Layer   │   │
│  └────┬─────┘  └────┬─────┘  └────┬─────┘  └────┬─────┘   │
└───────┼────────────┼─────────────┼─────────────┼──────────┘
        │            │             │             │
        └────────────┴─────────────┴─────────────┘
                         │ 调用
                         ▼
┌─────────────────────────────────────────────────────────────┐
│                   领域层 (domain/)                           │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐     │
│  │  data_view   │  │data_under    │  │  resource    │     │
│  │   Domain     │  │  standing    │  │  catalog     │     │
│  │              │  │   Domain     │  │   Domain     │     │
│  ├──────────────┤  ├──────────────┤  ├──────────────┤     │
│  │   Entity     │  │   Entity     │  │   Entity     │     │
│  │  Repository  │  │  Repository  │  │  Repository  │     │
│  │   Service    │  │   Service    │  │   Service    │     │
│  └──────┬───────┘  └──────┬───────┘  └──────┬───────┘     │
└─────────┼──────────────────┼──────────────────┼────────────┘
          │                  │                  │ 接口依赖
          └──────────────────┴──────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────────────┐
│                基础设施层 (infrastructure/)                   │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐     │
│  │   MySQL      │  │    Redis     │  │    Kafka     │     │
│  │ Persistence  │  │    Cache     │  │   Message    │     │
│  └──────────────┘  └──────────────┘  └──────────────┘     │
└─────────────────────────────────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────────────┐
│                  公共层 (pkg/)                               │
│     Config | Middleware | Response | ErrorX | Utils        │
└─────────────────────────────────────────────────────────────┘
```

## 分层详解

### 1️⃣ 应用层 (Application Layer)

**职责**: 接收外部请求，编排业务逻辑，调用领域服务

#### API层 (app/api/)
适用场景：简单的CRUD操作

**示例代码**:
```go
// app/api/resource_catalog/handler/category_handler.go
func (h *CategoryHandler) GetCategory(w http.ResponseWriter, r *http.Request) {
    // 1. 参数验证
    id := getIDFromRequest(r)
    
    // 2. 调用Domain服务
    category, err := h.categoryService.GetByID(r.Context(), id)
    
    // 3. 返回结果
    response.Success(w, category)
}
```

**特点**:
- ✅ 简单直接，性能高
- ✅ 适合单一Domain调用
- ❌ 不适合复杂业务编排

#### BFF层 (app/bff/)
适用场景：复杂业务聚合

**示例代码**:
```go
// app/bff/admin/logic/statistics_logic.go
func (l *StatisticsLogic) GetDashboard(ctx context.Context) (*Dashboard, error) {
    var wg sync.WaitGroup
    var catalogStats, queryStats, verifyStats interface{}
    
    // 并发调用多个Domain服务
    wg.Add(3)
    go func() {
        catalogStats = l.catalogService.GetStats(ctx)
        wg.Done()
    }()
    go func() {
        queryStats = l.queryService.GetStats(ctx)
        wg.Done()
    }()
    go func() {
        verifyStats = l.verifyService.GetStats(ctx)
        wg.Done()
    }()
    wg.Wait()
    
    // 聚合数据
    return l.aggregateStats(catalogStats, queryStats, verifyStats)
}
```

**特点**:
- ✅ 支持复杂业务编排
- ✅ 可按端（Admin/Web/Mobile）定制
- ✅ 支持并发调用多个Domain

#### Job层 (app/job/)
适用场景：定时任务

**示例代码**:
```go
// app/job/sync_data/sync_data_job.go
func (j *SyncDataJob) Run(ctx context.Context) error {
    // 1. 从外部系统获取数据
    externalData := j.fetchExternalData()
    
    // 2. 调用Domain服务处理
    err := j.categoryService.SyncCategories(ctx, externalData)
    
    // 3. 发送完成事件（可选）
    j.kafkaProducer.SendMessage("sync_completed", event)
    
    return err
}
```

#### Consumer层 (app/consumer/)
适用场景：消息队列消费

**示例代码**:
```go
// app/consumer/catalog_consumer/catalog_consumer.go
func (c *CatalogConsumer) Handle(ctx context.Context, msg kafka.Message) error {
    // 1. 解析消息
    var event CatalogEvent
    json.Unmarshal(msg.Value, &event)
    
    // 2. 调用Domain服务
    switch event.EventType {
    case "created":
        return c.categoryService.HandleCreated(ctx, event.Data)
    case "updated":
        return c.categoryService.HandleUpdated(ctx, event.Data)
    }
    
    return nil
}
```

---

### 2️⃣ 领域层 (Domain Layer)

**职责**: 核心业务逻辑，不依赖任何框架

#### Entity (实体)
定义业务对象和业务规则

**示例代码**:
```go
// domain/resource_catalog/entity/category.go
type Category struct {
    ID     int64
    Name   string
    Code   string
    Status int
}

// 业务规则
func (c *Category) Validate() error {
    if c.Name == "" {
        return errors.New("名称不能为空")
    }
    if c.Code == "" {
        return errors.New("编码不能为空")
    }
    return nil
}

func (c *Category) IsActive() bool {
    return c.Status == 1
}
```

#### Repository (仓储接口)
定义数据访问接口，**不实现**

**示例代码**:
```go
// domain/resource_catalog/repository/category_repository.go
type CategoryRepository interface {
    Create(ctx context.Context, category *entity.Category) error
    Update(ctx context.Context, category *entity.Category) error
    FindByID(ctx context.Context, id int64) (*entity.Category, error)
    List(ctx context.Context, page, pageSize int) ([]*entity.Category, int64, error)
}
```

#### Service (领域服务)
核心业务逻辑

**示例代码**:
```go
// domain/resource_catalog/service/category_service.go
type CategoryService struct {
    repo repository.CategoryRepository
}

func (s *CategoryService) Create(ctx context.Context, category *entity.Category) error {
    // 1. 业务验证
    if err := category.Validate(); err != nil {
        return err
    }
    
    // 2. 检查唯一性
    existing, _ := s.repo.FindByCode(ctx, category.Code)
    if existing != nil {
        return errors.New("编码已存在")
    }
    
    // 3. 创建
    return s.repo.Create(ctx, category)
}
```

**关键原则**:
- ✅ 纯业务逻辑，不依赖HTTP、gRPC等
- ✅ 可被API、BFF、Job、Consumer复用
- ✅ 易于单元测试
- ❌ 不能依赖app层
- ❌ Domain之间不能相互依赖

---

### 3️⃣ 基础设施层 (Infrastructure Layer)

**职责**: 实现Domain层定义的接口

#### Persistence (持久化)
实现Repository接口

**示例代码**:
```go
// infrastructure/persistence/mysql/category_repository_impl.go
type CategoryRepositoryImpl struct {
    db *sql.DB
}

func (r *CategoryRepositoryImpl) Create(ctx context.Context, category *entity.Category) error {
    query := `INSERT INTO categories (name, code, status) VALUES (?, ?, ?)`
    result, err := r.db.ExecContext(ctx, query, category.Name, category.Code, category.Status)
    if err != nil {
        return err
    }
    id, _ := result.LastInsertId()
    category.ID = id
    return nil
}
```

#### MQ (消息队列)
Kafka生产者和消费者封装

**示例代码**:
```go
// infrastructure/mq/kafka/kafka.go
type Producer struct {
    writer *kafka.Writer
}

func (p *Producer) SendMessage(ctx context.Context, key string, value interface{}) error {
    data, _ := json.Marshal(value)
    return p.writer.WriteMessages(ctx, kafka.Message{
        Key:   []byte(key),
        Value: data,
    })
}
```

---

### 4️⃣ 公共层 (PKG Layer)

**职责**: 提供通用工具，被所有层使用

包含：
- **config**: 配置加载
- **middleware**: HTTP中间件
- **response**: 统一响应格式
- **errorx**: 错误码管理
- **utils**: 工具函数
- **logger**: 日志封装

---

## 数据流示例

### 用户创建类别的完整流程

```
1. 客户端
   │ POST /api/v1/categories
   │ {"name": "测试类别", "code": "TEST"}
   ▼
2. API层 (app/api/resource_catalog/handler/)
   │ func CreateCategory(w, r)
   │ - 解析请求
   │ - 参数验证
   ▼
3. Domain层 (domain/resource_catalog/service/)
   │ func CategoryService.Create(ctx, category)
   │ - 业务验证
   │ - 检查唯一性
   ▼
4. Infrastructure层 (infrastructure/persistence/mysql/)
   │ func CategoryRepoImpl.Create(ctx, category)
   │ - 执行SQL插入
   │ - 返回新ID
   ▼
5. 返回响应
   │ {"code": 0, "msg": "success", "data": {...}}
```

## 依赖规则

### ✅ 允许的依赖
```
app层 → domain层
app层 → pkg层
domain层 → pkg层
infrastructure层 → domain层 (实现接口)
infrastructure层 → pkg层
```

### ❌ 禁止的依赖
```
domain层 ✗ app层
domain/A ✗ domain/B (Domain间禁止依赖)
infrastructure层 ✗ app层
pkg层 ✗ 任何业务层
```

## 多数据库策略

每个Domain使用独立数据库：

```yaml
DataSources:
  DataView:          # 数据视图数据库
    Source: root:pass@tcp(db:3306)/idrm_data_view
  
  DataUnderstanding: # 数据理解数据库
    Source: root:pass@tcp(db:3306)/idrm_data_understanding
  
  ResourceCatalog:   # 资源目录数据库
    Source: root:pass@tcp(db:3306)/idrm_resource_catalog
```

**优势**:
- ✅ 数据隔离，互不影响
- ✅ 支持后续微服务拆分
- ✅ 独立的数据库优化策略

## 服务部署架构

```
┌─────────────┐   ┌─────────────┐   ┌─────────────┐
│ api-server  │   │ job-server  │   │  consumer   │
│   :8080     │   │   (cron)    │   │   -server   │
└──────┬──────┘   └──────┬──────┘   └──────┬──────┘
       │                 │                  │
       └─────────────────┴──────────────────┘
                         │
              ┌──────────┴──────────┐
              │                     │
    ┌─────────▼─────────┐  ┌───────▼────────┐
    │   MySQL x3        │  │     Kafka      │
    │ (3个独立数据库)    │  │   (事件流)     │
    └───────────────────┘  └────────────────┘
```

3个服务共享Domain层代码，但可独立部署和扩缩容。

## 总结

IDRM的分层架构具有以下特点：

1. **清晰的职责划分**: 每层职责明确
2. **Domain核心**: 业务逻辑集中在Domain层，易于复用和测试
3. **灵活的应用层**: API/BFF/Job/Consumer满足不同场景
4. **基础设施隔离**: 通过接口隔离，易于替换实现
5. **独立部署**: 3个服务可独立扩缩容
6. **数据隔离**: 每个Domain独立数据库

这种架构既满足当前API为主的需求，又为后续微服务化预留了扩展空间。
